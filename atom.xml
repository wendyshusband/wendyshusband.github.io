<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kylin&#39;s blogs</title>
  <subtitle>独立之精神，自由之思想。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-09-01T15:44:21.800Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>kylin</name>
    <email>tkl449@126.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Serialize binary tree and Deserialize binary tree</title>
    <link href="http://yoursite.com/2017/09/01/Serialize%20binary%20tree%20and%20Deserialize%20binary%20tree/"/>
    <id>http://yoursite.com/2017/09/01/Serialize binary tree and Deserialize binary tree/</id>
    <published>2017-09-01T15:30:03.000Z</published>
    <updated>2017-09-01T15:44:21.800Z</updated>
    
    <content type="html"><![CDATA[<p>面试题一道。序列化与反序列化二叉树<br><a id="more"></a></p>
<p><a href="https://www.nowcoder.com/questionTerminal/cf7e25aa97c04cc1a68c8f040e71fb84" target="_blank" rel="external">牛客网真题链接</a></p>
<p>定义：</p>
<ol>
<li>序列化： 将数据结构或对象转换成二进制串的过程。</li>
<li>反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。</li>
</ol>
<p>思路：</p>
<ol>
<li><p>序列化：将二叉树转化成一个字符串，每个节点用分隔符分开。由于二叉树的结构可以由其先序遍历和中序遍历结果来决定。一开始想到用二者的结合，后来觉得太麻烦了。不如直接就用一个，只要把整棵树用特殊字符将空值填充称完全二叉树就行了。有了这个思想，其实不管什么遍历，都可以实现序列化。</p>
</li>
<li><p>反序列化：模拟遍历。</p>
</li>
</ol>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">package interview.leetcode;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by 44931 on 2017/9/1.</div><div class="line"> */</div><div class="line">public class Solution2 &#123;</div><div class="line">    int index = -1;</div><div class="line"></div><div class="line">    public static class TreeNode &#123;</div><div class="line">        int val = 0;</div><div class="line">        TreeNode left = null;</div><div class="line">        TreeNode right = null;</div><div class="line"></div><div class="line">        public TreeNode(int val) &#123;</div><div class="line">            this.val = val;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    String Serialize(TreeNode root, StringBuffer stringBuffer) &#123;</div><div class="line"></div><div class="line">        if (null == root) &#123;</div><div class="line">            return String.valueOf(stringBuffer.append(&quot;#,&quot;));</div><div class="line">        &#125;</div><div class="line">        stringBuffer.append(String.valueOf(root.val)+&quot;,&quot;);</div><div class="line">        Serialize(root.left, stringBuffer);</div><div class="line">        Serialize(root.right, stringBuffer);</div><div class="line">        return String.valueOf(stringBuffer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    String Serialize(TreeNode root) &#123;</div><div class="line">        StringBuffer stringBuffer = new StringBuffer();</div><div class="line">        return Serialize(root, stringBuffer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    TreeNode Deserialize(String str) &#123;</div><div class="line">        index++;</div><div class="line">        int len = str.length();</div><div class="line">        if(index &gt;= len)&#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        String[] strr = str.split(&quot;,&quot;);</div><div class="line">        TreeNode node = null;</div><div class="line">        if(!strr[index].equals(&quot;#&quot;))&#123;</div><div class="line">            node = new TreeNode(Integer.valueOf(strr[index]));</div><div class="line">            node.left = Deserialize(str);</div><div class="line">            node.right = Deserialize(str);</div><div class="line">        &#125;</div><div class="line">            return node;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    TreeNode Deserialize(String[] temp) &#123;</div><div class="line">        index++;</div><div class="line">        if (temp.length &lt; 1 || index &lt; 0 || temp.length &lt; index || temp[index].equals(&quot;#&quot;)) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        TreeNode root = new TreeNode(Integer.valueOf(temp[index]));</div><div class="line">        root.left = Deserialize(temp);</div><div class="line">        root.right = Deserialize(temp);</div><div class="line">        return root;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void frontSearch(TreeNode node) &#123;</div><div class="line">        if (node == null) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        System.out.println(node.val);</div><div class="line">        frontSearch(node.left);</div><div class="line">        frontSearch(node.right);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Solution2 solution2 = new Solution2();</div><div class="line">        TreeNode n1 = new TreeNode(1);</div><div class="line">        TreeNode n2 = new TreeNode(2);</div><div class="line">        TreeNode n3 = new TreeNode(3);</div><div class="line">        TreeNode n4 = new TreeNode(4);</div><div class="line">        TreeNode n5 = new TreeNode(5);</div><div class="line">        TreeNode n6 = new TreeNode(6);</div><div class="line">        TreeNode n7 = new TreeNode(7);</div><div class="line">        TreeNode n8 = new TreeNode(8);</div><div class="line">        TreeNode n9 = new TreeNode(9);</div><div class="line"></div><div class="line">        n1.left = n2;</div><div class="line">        n1.right = n3;</div><div class="line">        n2.left = n4;</div><div class="line">        n2.right = n5;</div><div class="line">        n3.left = n6;</div><div class="line">        n3.right = n7;</div><div class="line">        n4.left = n8;</div><div class="line">        n4.right = n9;</div><div class="line">        System.out.println(solution2.Serialize(n1));</div><div class="line">        frontSearch(solution2.Deserialize(solution2.Serialize(n1)));</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试题一道。序列化与反序列化二叉树&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="Binary tree" scheme="http://yoursite.com/tags/Binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-Letter Combinations of a Phone Number</title>
    <link href="http://yoursite.com/2017/09/01/leetcode-Letter%20Combinations%20of%20a%20Phone%20Number/"/>
    <id>http://yoursite.com/2017/09/01/leetcode-Letter Combinations of a Phone Number/</id>
    <published>2017-09-01T09:12:38.000Z</published>
    <updated>2017-09-01T15:44:53.900Z</updated>
    
    <content type="html"><![CDATA[<p>很有意思的一道题。<br><a id="more"></a><br>leetcode 原题：<br>Given a digit string, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below.</p>
<p>Input:Digit string “23”<br>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].<br>Note:<br>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>
<p>给定一个数字字符串，每个数字和字母的映射参考功能机的键盘。求有多少种不同的字母组合。</p>
<p>这个题其实很简单。每个数字对应3-4个字母，有n个数字，输出所有可能的组合。数字顺序不能调换，是一个组合问题而不是排列问题。很直观的就想到使用递归的方法。提取第i个数字对应的字母(使用字典咯)，针对每个字母递归进入第i+1个数字直到i=n,返回当前生成的字符串。</p>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">     public List&lt;String&gt; letterCombinations(String digits) &#123;</div><div class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line">        if (digits.isEmpty()) &#123;</div><div class="line">            return list;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String[] dict = new String[]&#123;&quot; &quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;;</div><div class="line">        letterCombinationsRecursion(digits, dict, 0, &quot;&quot;, list);</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void letterCombinationsRecursion(String digits, String[] dict, int level, String out, ArrayList&lt;String&gt; list) &#123;</div><div class="line">        if (level == digits.length()) &#123;</div><div class="line">            list.add(out);</div><div class="line">        &#125; else &#123;</div><div class="line">            String str = dict[digits.charAt(level) - &apos;0&apos;];</div><div class="line">            for (int i=0; i&lt;str.length(); i++) &#123;</div><div class="line">                out += str.charAt(i);</div><div class="line">                letterCombinationsRecursion(digits, dict, level+1, out, list);</div><div class="line">                out = out.substring(0,out.length()-1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>思考：看到这类限定性很强，或者枚举空间很小的题，总是会松懈，这样不行，做事要严谨一点。不要什么都想着用字典啊之类的暴力的方法，多想一些漂亮的数学上的解法。<br>更多解法：<a href="http://www.cnblogs.com/grandyang/p/4452220.html" target="_blank" rel="external">here</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很有意思的一道题。&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Storm, Flink和spark Streaming中的backpressure机制比较</title>
    <link href="http://yoursite.com/2017/08/30/Storm,%20Flink%E5%92%8Cspark%20Streaming%E4%B8%AD%E7%9A%84backpressure%E6%9C%BA%E5%88%B6%E6%AF%94%E8%BE%83/"/>
    <id>http://yoursite.com/2017/08/30/Storm, Flink和spark Streaming中的backpressure机制比较/</id>
    <published>2017-08-30T15:22:56.000Z</published>
    <updated>2017-09-01T15:44:48.701Z</updated>
    
    <content type="html"><![CDATA[<p> Storm, Spark streaming, Flink中的backpressure机制比较。<br><a id="more"></a></p>
<p><br>backpressure是分布式流处理系统中一种有效的流量控制手段，为了防止负载过大，计算瓶颈等对整个系统带来的影响。backpressure基本上是每个流处理系统都应该考虑的一种流量控制手段。流量控制的方法有很多种，有兴趣的可以去看看网络中是怎么控制流量的。分布式流其实和网络流的本质是一样的。<br></p><br><p><br>本文先分别讨论各个系统的backpressure机制，然后再总结三者的异同。<br></p>

<h2 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h2><p>storm的backpressure功能流程如下：</p><br><p>在worker中会有一个backpressure线程，实时的监控executor的receive queue或者worker的transfer queue的状态，一旦发现某一queue中的数据量超过一个阈值（由 <strong>backpressure.disruptor.high.watermark</strong> 配置，默认为0.9），即触发backpressure，此时backpressure线程会将这当前topology的信息写入zookeeper，watcher检测到zookeeper中的数据变化，则立马通知所有worker进入backpressure状态，上游spout停止发送数据,直到queue中的数据量低于一个阈值（由 <strong>backpressure.disruptor.low.watermark</strong> 配置，默认为0.4）。所有worker退出backpressure状态，spout正常发送数据。</p><br>executor.clj中代码段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(if (and (not (.isFull transfer-queue))</div><div class="line">                     (not throttle-on)</div><div class="line">                     (not reached-max-spout-pending))</div><div class="line">                 (fast-list-iter [^ISpout spout spouts] (.nextTuple spout))))</div></pre></td></tr></table></figure><br><br><p>不了解disruptor queue在storm中的使用的可以参考：<a href="http://www.michael-noll.com/blog/2012/10/16/understanding-the-parallelism-of-a-storm-topology/" target="_blank" rel="external">Understanding the Parallelism of a Storm Topology</a><br></p><br><p><br>storm中的backpressure还是相当暴力的。这样子其实整个系统都处在一个不稳定的状态，堵住了马上就不发送任何数据进来，直到疏通了，开始发送，然后慢慢堵住，直到触发backpressure。<br></p>

<p>storm backpressure具体内容参考：<a href="https://github.com/apache/storm/pull/700" target="_blank" rel="external">storm-886</a></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://ovjcsnet2.bkt.clouddn.com/stormbackpressure.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h2><p>Flink是新一代的流处理系统，其backpressure的实现方式相比于storm有很大的区别。其不再借助zookeeper或者其他的外部组件来实现backpressure。而是在其内部数据传输时用一种类似阻塞队列的方式很合理，很漂亮的实现了这一功能。</p><br><p>具体流程已经有人写了很好的<a href="http://wuchong.me/blog/2016/04/26/flink-internals-how-to-handle-backpressure/" target="_blank" rel="external">博文</a>了,我就不再多次一举了。</p>

<h2 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h2><p>待研究。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; Storm, Spark streaming, Flink中的backpressure机制比较。&lt;br&gt;
    
    </summary>
    
      <category term="Storm学习总结" scheme="http://yoursite.com/categories/Storm%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Distributed system" scheme="http://yoursite.com/tags/Distributed-system/"/>
    
      <category term="Storm" scheme="http://yoursite.com/tags/Storm/"/>
    
      <category term="Spark" scheme="http://yoursite.com/tags/Spark/"/>
    
      <category term="Flink" scheme="http://yoursite.com/tags/Flink/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-Longest Substring Without Repeating Characters</title>
    <link href="http://yoursite.com/2017/08/23/leetcode-Longest%20Substring%20Without%20Repeating%20Characters/"/>
    <id>http://yoursite.com/2017/08/23/leetcode-Longest Substring Without Repeating Characters/</id>
    <published>2017-08-23T14:53:38.000Z</published>
    <updated>2017-09-01T15:44:52.946Z</updated>
    
    <content type="html"><![CDATA[<p>寻找最长无重复子串的最优解法<br><a id="more"></a><br>leetcode 原题：<br>Given a string, find the length of the longest substring without repeating characters.</p>
<p>Examples:</p>
<p>Given “abcabcbb”, the answer is “abc”, which the length is 3.</p>
<p>Given “bbbbb”, the answer is “b”, with the length of 1.</p>
<p>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p>
<p>网上有很多不同类型的解法，这里不做一一介绍，提供一个时间复杂度O(n)，空间复杂度O(1)的解法如下：</p>
<p>思路：</p>
<ol>
<li><p>该问题的通常解法是遍历每个字符起始的子串，找出结果。在计算过程中使用hash存储中间结果。通过遍历的方式时间复杂度为O(n^2)。</p>
</li>
<li><p>可以考虑使用DP，因为对于字符串中的一个字符而言，如果其与 <em>其前面字符结尾的最长不重复子串</em> 中的字符没有重复的话。那么就可以将其加入到最长不重复子串中，则以当前字符结尾的子串长度为其前面找到的子串长度+1。若有重复，如果有重复，且重复位置在上一个最长子串起始位置之后，那么就与该起始位置之后的稍短的子串构成新的子串或者单独成一个新子串。dp表中记录以每个字符结尾的最长不重复子串。<br>例如：有字符串abccd,有dp[0]=1,dp[1]=2,dp[2]=3。那么当找到第二个c时，此时以第一个c结尾的最长不重复子串长度为dp[2]=3（abc），发现有重复，则修改：dp[3]=1。找到d时，与前面的不重复子串没有相同字符，故dp[4]=2。<br>这样的dp算法的时间复杂度为O(n^2)。因为每次我们都需要“回头”去寻找重复元素的位置。</p>
</li>
<li><p>怎么样才能不回头找呢？用hash咯。可以用hash记录元素是否出现过，key为元素值，value为元素上一次出现的位置。同时可以发现，其实我们不需要维护一张DP表，因为我们只需要记住以当前元素的前一个元素结尾的最长不重复子串的长度即可。所以可以进一步优化空间使用从O(n) -&gt; O(1)。</p>
</li>
</ol>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line"></div><div class="line">    public int lengthOfLongestSubstring(String s) &#123;</div><div class="line">        if (s == null || s.length() &lt;= 0)</div><div class="line">            return 0;</div><div class="line">        int maxLen = 1;</div><div class="line">        int lastIndex = 0;</div><div class="line">        int current = 1;</div><div class="line">        HashMap&lt;Character,Integer&gt; map = new HashMap&lt;&gt;();</div><div class="line">        map.put(s.charAt(0),0);</div><div class="line">        for (int i=1; i&lt;s.length(); i++) &#123;</div><div class="line">            if (map.get(s.charAt(i)) == null) &#123;</div><div class="line">                map.put(s.charAt(i), i);</div><div class="line">                current++;</div><div class="line">            &#125; else if (lastIndex &lt;= map.get(s.charAt(i))) &#123;</div><div class="line">                current = i - map.get(s.charAt(i));</div><div class="line">                lastIndex = map.get(s.charAt(i))+1;</div><div class="line">                map.put(s.charAt(i), i);</div><div class="line">            &#125; else &#123;</div><div class="line">                current++;</div><div class="line">                map.put(s.charAt(i), i);</div><div class="line">            &#125;</div><div class="line">            if (current &gt; maxLen) &#123;</div><div class="line">                maxLen = current;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return maxLen;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>参考：<br><a href="http://xfhnever.com/2014/10/30/algorithm-lnrs/" target="_blank" rel="external">http://xfhnever.com/2014/10/30/algorithm-lnrs/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;寻找最长无重复子串的最优解法&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>《二十二》观后感</title>
    <link href="http://yoursite.com/2017/08/19/%E3%80%8A%E4%BA%8C%E5%8D%81%E4%BA%8C%E8%A7%82%E5%90%8E%E6%84%9F%E3%80%8B/"/>
    <id>http://yoursite.com/2017/08/19/《二十二观后感》/</id>
    <published>2017-08-19T02:32:50.000Z</published>
    <updated>2017-08-19T03:29:55.451Z</updated>
    
    <content type="html"><![CDATA[<p>电影《二十二》观后感，有剧透，不喜勿看。<br><a id="more"></a></p>
<p>第一次看电影，全场安静无声音，灯亮后没有人离开，全部安静的坐着静静的听完片尾曲才慢慢离开。</p>
<p>如果说什么样的电影是好电影，我想这样的电影才是好电影。我不去谈论她是否符合一个纪录片应有的标准，也不care她是否有剧情，有高潮，有…… 这只是一部真实记录老人们现状的影片，没有任何多余的修饰，只是安静的记录着制作组所看到的真实的老人们的生活，没有对历史仇恨的刻意渲染，也不会卖弄老人们的眼泪来博取大家的同情。我想这才是这种类型的纪录片应有的样子。</p>
<p>老人们的生活很平静，安静的坐着，就能坐上一整天。回想起过去，表达出来的都是不愿再提及的态度。对于她们来说，过去的也许真的就已经过去了。她们会看着日本老兵的照片笑道：“日本人也老咯，头也秃了，都没有胡子咯。”， 仇恨随着时间的流逝已经慢慢变淡了，但她们想起坐着火车离她们远去的母亲，想起被日本人杀害的妈妈还是会泪流满面，经过岁月的洗礼，留下来的只有爱却没有恨，这是我在影片里看到的最美好的东西。</p>
<p>影片一开始，出现了一个韩国人，我看到时我以为是一个日本人，我还在想把一个日本人搞进来拍拍拍是不是不太合适，后来知道是韩国人就释怀了许多。等到影片快结束时，真的出现了一个日本人，在海南为这些奶奶们尽着自己的力。这时我却没有什么太多的抵触了。我想看完这部电影真的能化解一个人身上的戾气。是我自己庸俗了。</p>
<p>看到一半时我会想，为什么这些老人的物质生活条件看上去并不是那么的好，是我们的国家没有给予他们应有的帮助吗？但我看到海南那位去世的老奶奶房间里留下来的志愿者们送来的棉被等等东西的时候，我才终于明白过来，这些老人需要的并不是多么优异的物质条件，他们已经平淡的过了这么多年，他们需要的只是没有人打扰的安静的生活。</p>
<p>影片结尾时，片头出来的葬礼主持人，呼应了32年这个伏笔。他从82开始为这些受害者们与日本政府斗争，这么多年来已经麻木了，觉得自己年轻时太天真，只想着为她们讨回公道，现在都看淡了。其实我个人对于去日本打官司这种与虎谋皮的行为是不太赞同的。我们的斗争，是要让人类记住这样的过去，让不管是日本人还是其他国家的人也好，看清这件事里面的是非曲直。就算日本人不道歉，他们心里也应该很清楚，谁对谁错。对的就是对的，错的就是错的。但对于我们自己而言，中国人，我们要知道的不应该仅仅是日本人怎么怎么样。更应该知道我们自己人是怎么对待这些受害者的，记住那个日本人的儿子，七十年没有结婚的老爷爷。这是我们自己人对自己人的歧视，是我们这个民族自身所存在的问题。这些才是我们应该要重视起来的。反省自己，更好的面向未来。</p>
<p>2017年，据制作组的统计，二十二人中现在已经只剩下八人，很可能在未来的几年里。这个数字将会变为0。这些数字会被写进书里，这段过去会被称为了历史。很多很多年后，当人们看到这些数字，这段历史的时候并不会有太多的感悟和感觉。就像我们现在看到古代的大屠杀时，没有任何感觉，十万，百万只是一个冰冷的数字而已。我们更应该做的，是留下在心里传承下去的东西，文化。这才是我们这个民族的灵魂。</p>
<p>很讨厌那帮逼逼弱肉强食，适者生存的人。人类社会发展的意义何在？如果我们社会的发展不能带来全人类生活的共同改善，不能带来全人类的平等和自由，却还是和原始的自然一样弱肉强食，两级分化，贫富悬殊，那我们人类为之奋斗的到底又是什么呢？</p>
<p>我们的社会的形成，组织和发展无法逃避自然规律的约束，但我们至少应该让自己和纯粹的自然社会区分开来。</p>
<p>愿这些老奶奶，下辈子做一个快乐的女孩。</p>
<p>PS：感触很深的一点，这些老奶奶差不多都是1920年代出生的人，抗战时她们大部分才只有13,14岁。这些是活着的，之前死去的那些20多岁，30多岁的。他们也许受到更多更久的欺凌。我们看到的只是冰山一角。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;电影《二十二》观后感，有剧透，不喜勿看。&lt;br&gt;
    
    </summary>
    
      <category term="日常随笔" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="影评" scheme="http://yoursite.com/tags/%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>spring学习笔记(1)-基本概念</title>
    <link href="http://yoursite.com/2017/08/17/Spring%E5%AD%A6%E4%B9%A0(1)/"/>
    <id>http://yoursite.com/2017/08/17/Spring学习(1)/</id>
    <published>2017-08-17T04:43:56.000Z</published>
    <updated>2017-09-01T07:57:09.982Z</updated>
    
    <content type="html"><![CDATA[<p>Spring基本概念<br><a id="more"></a></p>
<h2 id="Inversion-of-Control-And-Dependency-Injection"><a href="#Inversion-of-Control-And-Dependency-Injection" class="headerlink" title="Inversion of Control And Dependency Injection"></a>Inversion of Control And Dependency Injection</h2><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IOC是一种设计的思想，在程序设计时并不直接在某个对象内部去new一个其他对象，而是使用一个IOC容器来创建这些对象。使用IOC容器来控制对象，主要控制外部资源的获取。</p>
<p>所谓inversion，指的就是由容器来帮忙创建及注入依赖对象。依赖对象的获取由主动变为被动，这是一个反转。应用被动的等待IOC容器来创建注入它所需要的资源。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://sishuok.com/forum/upload/2012/2/19/6fdf1048726cc2edcac4fca685f050ac__2.JPG" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><p>应用依赖于IOC容器。因为其需要IOC容器来提供外部资源。IOC将这些外部资源注入某个对象。</p>
<p>其实依赖注入只是一种装配对象的手段，设计的类结构才是基础，如果设计的类结构不支持依赖注入，Spring IoC容器也注入不了任何东西。</p>
<h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h4><p>很显然，循环依赖是指的，当创建A时，需要B，就去创建B，创建B时发现需要A。此时就有问题了，因为A还没创建完成，然后就去新建一个A，这样就会陷入死循环。</p>
<h2 id="Aspect-Orient-Programming-面向切面编程"><a href="#Aspect-Orient-Programming-面向切面编程" class="headerlink" title="Aspect Orient Programming 面向切面编程"></a>Aspect Orient Programming 面向切面编程</h2><p><a href="http://jinnianshilongnian.iteye.com/blog/1418596" target="_blank" rel="external">http://jinnianshilongnian.iteye.com/blog/1418596</a></p>
<p>在进行OOP开发时，都是基于对组件（比如类）进行开发，然后对组件进行组合，OOP最大问题就是无法解耦组件进行开发，比如我们上边举例，而AOP就是为了克服这个问题而出现的，它来进行这种耦合的分离。AOP为开发者提供一种进行横切关注点。<br><em>（比如日志关注点横切了支付关注点）</em> 分离并织入的机制，把横切关注点分离，然后通过某种技术织入到系统中，从而无耦合的完成了我们的功能。</p>
<p>关注点：可以认为是所关注的任何东西，比如上边的支付组件；<br>关注点分离：将问题细化从而单独部分，即可以理解为不可再分割的组件，如上边的日志组件和支付组件；<br>横切关注点：一个组件无法完成需要的功能，需要其他组件协作完成，如日志组件横切于支付组件；</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring基本概念&lt;br&gt;
    
    </summary>
    
      <category term="java学习总结" scheme="http://yoursite.com/categories/java%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>storm资源汇总</title>
    <link href="http://yoursite.com/2017/08/10/storm%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2017/08/10/storm资源汇总/</id>
    <published>2017-08-10T12:36:59.000Z</published>
    <updated>2017-09-01T15:37:03.328Z</updated>
    
    <content type="html"><![CDATA[<p>Apache storm 的一些网络资源汇总。<br><a id="more"></a></p>
<h2 id="storm入门"><a href="#storm入门" class="headerlink" title="storm入门"></a>storm入门</h2><p><a href="http://storm.apache.org/" target="_blank" rel="external">官网地址</a></p>
<p><a href="https://github.com/apache/storm" target="_blank" rel="external">源码地址</a></p>
<p><a href="http://dl.acm.org/citation.cfm?id=2595641" target="_blank" rel="external">storm@twitter</a></p>
<p><a href="https://yq.aliyun.com/articles/25772" target="_blank" rel="external">部署教程</a></p>
<p><a href="https://github.com/apache/storm/blob/v1.0.1/conf/defaults.yaml" target="_blank" rel="external">Default configuration</a></p>
<p><a href="https://my.oschina.net/tkl/blog/719618" target="_blank" rel="external">storm配置项</a></p>
<h2 id="相关博客"><a href="#相关博客" class="headerlink" title="相关博客"></a>相关博客</h2><ol>
<li><p>fxjwind的博文，有部分源码解读是老版本的storm。1.0.X的版本之后会有一些变动的地方（如worker如何接收数据）。但作为storm源码阅读的辅助，这些博文还是相当牛逼的。向fxjwind大神致敬。 <a href="http://www.cnblogs.com/fxjwind/category/455987.html" target="_blank" rel="external">http://www.cnblogs.com/fxjwind/category/455987.html</a></p>
</li>
<li><p>徽沪一郎 Blog - Apache Storm 源码走读系列。很cool的博客。 <a href="http://www.cnblogs.com/hseagle/p/3756862.html" target="_blank" rel="external">http://www.cnblogs.com/hseagle/p/3756862.html</a></p>
</li>
</ol>
<h2 id="Some-important-concept"><a href="#Some-important-concept" class="headerlink" title="Some important concept"></a>Some important concept</h2><ol>
<li><p><a href="http://www.michael-noll.com/blog/2013/06/21/understanding-storm-internal-message-buffers/" target="_blank" rel="external">Understanding the Internal Message Buffers of Storm</a></p>
</li>
<li><p><a href="http://www.michael-noll.com/blog/2012/10/16/understanding-the-parallelism-of-a-storm-topology/" target="_blank" rel="external">Understanding the Parallelism of a Storm Topology</a></p>
</li>
<li><p><a href="https://github.com/weyo/Storm-Documents/blob/master/Manual/zh/Guaranteeing-Message-Processing.md" target="_blank" rel="external">Guaranteeing Message Processing</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/foreach-break/p/storm_at_least_once.html" target="_blank" rel="external">At least once</a></p>
</li>
<li><p><a href="https://github.com/nathanmarz/storm/wiki/Trident-tutorial" target="_blank" rel="external">storm trident</a></p>
</li>
<li><p><a href="http://storm.apache.org/releases/1.0.3/Metrics.html" target="_blank" rel="external">Storm Metrics</a></p>
</li>
<li><p><a href="http://ifeve.com/storm-distributed-rpc/" target="_blank" rel="external">DRPC详解，中文版译文</a></p>
</li>
<li><p><a href="https://my.oschina.net/HIJAY/blog/487125" target="_blank" rel="external">storm在zookeeper上的目录结构</a></p>
</li>
<li><p><a href="http://www.jasongj.com/2015/03/10/KafkaColumn1/" target="_blank" rel="external">kafka原理</a></p>
</li>
</ol>
<h2 id="storm-scheduler"><a href="#storm-scheduler" class="headerlink" title="storm scheduler"></a>storm scheduler</h2><p>storm 有多个不同的<a href="http://storm.apache.org/releases/1.0.3/Storm-Scheduler.html" target="_blank" rel="external">调度器</a>。包括 DefaultScheduler, IsolationScheduler, MultitenantScheduler, ResourceAwareScheduler等。</p>
<h2 id="相关项目"><a href="#相关项目" class="headerlink" title="相关项目"></a>相关项目</h2><ol>
<li><p><a href="https://zookeeper.apache.org/" target="_blank" rel="external">zookeeper</a></p>
</li>
<li><p><a href="https://thrift.apache.org/" target="_blank" rel="external">thrift</a>，推荐<a href="http://dongxicheng.org/search-engine/thrift-framework-intro/" target="_blank" rel="external">董的博客</a>。</p>
</li>
<li><p><a href="https://github.com/ADSC-Cloud/resa-drs" target="_blank" rel="external">Dynamic Resource Scheduling</a>，该项目支持storm在运行时动态调整资源。</p>
</li>
<li><p><a href="https://github.com/yahoo/storm-yarn" target="_blank" rel="external">storm on yarn</a>，利用资源调度框架YARN来调度storm资源。</p>
</li>
<li><p><a href="https://github.com/wendyshusband/storm-On-Docker-Swarm" target="_blank" rel="external">storm on docker</a>,在docker swarm集群里部署storm。</p>
</li>
<li><p><a href="https://github.com/alibaba/jstorm" target="_blank" rel="external">Jstorm</a>，alibaba开源的Java版本及优化版本的类storm流处理系统。</p>
</li>
</ol>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>感谢<a href="https://github.com/troyding" target="_blank" rel="external">troyding</a>，他的文章让我有了写这篇博客的想法。我的文章是基于他的<a href="https://github.com/troyding/resa/blob/master/doc/online-resources.md" target="_blank" rel="external">工作</a>完成的。<br>本文将持续更新。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Apache storm 的一些网络资源汇总。&lt;br&gt;
    
    </summary>
    
      <category term="Storm学习总结" scheme="http://yoursite.com/categories/Storm%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Distributed system" scheme="http://yoursite.com/tags/Distributed-system/"/>
    
      <category term="Storm" scheme="http://yoursite.com/tags/Storm/"/>
    
  </entry>
  
</feed>
